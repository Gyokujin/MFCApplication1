마이크로소프트 기초 클래스(Microsoft Foundation Class, MFC) : 윈도우 환경에서 작동하는 GUI 프로그램에 C++을 이용하여 개발을 돕는 라이브러리로 기존 WinAPI에 객체지향을 도입하여 확장된 형태이다.
객체지향 언어를 쓰는 이유 : 객체화되어 있으면 해당 객체와 관련 함수를 찾아보면 되기 때문. 클래스 선언 후 객체로 만드는 것으로 반복되는 코드를 없앨 수 있다.

SDL(Security Development Lifecycle) : 소프트웨어의 보안 개발 방법을 제공해 주는 보안 프로세스로 대표적으로 하트블리드 현상처럼 의도치 않은 메모리 접근을 막는 역할을 한다.

헝가리안식 표기 : 변수, 함수의 이름에 데이터 타입을 포함하여 정하는 표기법으로 해당 변수가 전역변수인지 부호가 있는지 없는지 등을 알 수 있다.

오버로딩 : 메서드의 이름은 같고 매개변수의 유형과 개수가 다른 함수를 새롭게 정의하는 것(리턴값만 다른 함수를 만드는 것은 불가능하다)
오버라이딩 : 상속받은 클래스에서 상위 클래스에 있던 메서드를 재정의 하는 것(기본 골자는 같아야 하기 때문에 매개변수, 리턴값은 같다)

포인터 : 메모리의 주소값을 저장하는 변수로 변수뿐만 아니라 자료구조의 내부로 접근등 사용법이 다양하다.
void pointer : 
변수에 타입이 필요한 이유 : (예시로 printf에 %d와 같이 자료형을 쓰는 이유 역시 같다.)
변수에 표현 범위가 있는 이유 : 
32 비트는 2를 32번 제곱한 메모리로 4GB를 최대로 지원한다. 64 비트는 16TB가 최대이다. (이때 이 메모리의 접근은 롱포인터를 이용한다.)
롱포인터 : 2^32 까지의 메모리에 접근 가능한 포인터
정적할당 : 사전에 미리 메모리를 할당 받는 구조
동적할당 :
메모리누수 : 
메모리난독화 : 
메모리페이징 : 
시리얼라이즈 : 

치트엔진 :

프로세스 : 
스레드 : 
테스크 : 
프로세스와 스레드의 차이 :
테스크와 스레드의 차이 :

잡스케쥴러 : 
뮤텍스 :
경쟁상태 :
ASync :
CPU에서 스레드 처리방식 :
듀얼코어에서 게임처리방식 :
멀티코어에서 게임처리방식 :
오버헤드 :
컨텍스트 스위칭 :
