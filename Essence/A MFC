마이크로소프트 기초 클래스(Microsoft Foundation Class, MFC) : 윈도우 환경에서 작동하는 GUI 프로그램에 C++을 이용하여 개발을 돕는 라이브러리로 기존 WinAPI에 객체지향을 도입하여 확장된 형태이다.
객체지향 언어를 쓰는 이유 : 객체화되어 있으면 해당 객체와 관련 함수를 찾아보면 되기 때문. 클래스 선언 후 객체로 만드는 것으로 반복되는 코드를 없앨 수 있다.

SDL(Security Development Lifecycle) : 소프트웨어의 보안 개발 방법을 제공해 주는 보안 프로세스로 대표적으로 하트블리드 현상처럼 의도치 않은 메모리 접근을 막는 역할을 한다.

헝가리안식 표기 : 변수, 함수의 이름에 데이터 타입을 포함하여 정하는 표기법으로 해당 변수가 전역변수인지 부호가 있는지 없는지 등을 알 수 있다.

오버로딩 : 메서드의 이름은 같고 매개변수의 유형과 개수가 다른 함수를 새롭게 정의하는 것(리턴값만 다른 함수를 만드는 것은 불가능하다)
오버라이딩 : 상속받은 클래스에서 상위 클래스에 있던 메서드를 재정의 하는 것(기본 골자는 같아야 하기 때문에 매개변수, 리턴값은 같다)

포인터 : 메모리의 주소값을 저장하는 변수로 변수뿐만 아니라 자료구조의 내부로 접근등 사용법이 다양하다.
void pointer : 데이터 타입. 즉 자료형을 미리 정하지 않은 포인터이다. 사용하기 위해 형변환을 하여 타 메모리에 접근한다.(메모리의 사이즈를 )
변수에 타입이 필요한 이유 : (예시로 printf에 %d와 같이 자료형을 쓰는 이유 역시 같다.)
변수에 표현 범위가 있는 이유 : 모든 자료는 0과 1의 숫자로 표현된다.(문자 또한 결국 0과 1로 나타낸다) 이때 표현할 수 있는 개수에 따라 자료형을 구분하게 된다. 참과 거짓을 표현하는 bool은 1비트,
문자 하나를 나타내는 char은 8비트, 숫자를 담는 int는 32비트(int의 범위는 여기서 결정된다. 2^32 : -2,147,483,648에서 2,147,483,647)

32 비트는 2를 32번 제곱한 메모리로 4GB를 최대로 지원한다. 64 비트는 16TB가 최대이다. (이때 이 메모리의 접근은 롱포인터를 이용한다.)
롱포인터 : 2^32 까지의 메모리에 접근 가능한 포인터
정적할당 : 사전에 미리 메모리를 할당 받는 구조
동적할당 : 실행중에 메모리를 할당 받는 구조
메모리누수 : 동적할당된 메모리를 해제하지 않아 사용하지 않는 데이터임에도 메모리의 점유율을 차지하는 것
메모리 난독화(Memory Obfuscation) : 보안 강화를 위해 코드나 데이터를 난독화 하여 해석하기 어렵게 만드는 난독화 기법중 하나로 XOR 연산등을 활용해 외부에서 접근하는 경우 원래 데이터 대신 변환된 값이 나타나게 하여 해석을 어렵게 만든다.
메모리페이징 : 메모리를 나누는 방법으로 메모리 주소와 메모리의 크기를 정해진 페이지 단위로 나누고 각각의 페이지를 프로세스에 할당하고 관리하는 기법
시리얼라이즈 : 객체를 네트워크 전송을 위해 변환하는 과정을 의미한다. 크래스플랫폼을 위해 사용해야하며 유니티에서도 SerializeField 선언으로 이것이 가능하다.(유니티 엔진에서는 변수를 Inspector에 노출되기 위해 public이나 SerializeField 선언을 하는것도 직렬화로 볼 수 있다.)

치트엔진 : 게임 플레이에 영향을 끼칠수 있는 데이터의 주소로 접근후 임의의 값을 변경하게 하여 비정상적인 게임 플레이를 하게 해주는 프로그램이다.

프로세스(Process) : main에서 작동하는 하나의 큰 흐름
스레드(Thread) : 프로세스내에서 진행되는 절차의 경로
테스크(Task) : 프로세스 내의 작업을 여러 작업자가 나눠서 수행한 뒤 다시 하나의 결과로 만드는 것. 계산 자원을 효율적으로 처리하기 위한 방법이다.
테스크와 스레드의 차이 :

잡스케쥴러 : 
뮤텍스 :
경쟁상태 : 씹힘 현상을 막기 위해 접근을 의도적으로 막는다.
ASync :
CPU에서 스레드 처리방식 :
듀얼코어에서 게임처리방식 :
멀티코어에서 게임처리방식 :
오버헤드 :
컨텍스트 스위칭 :

